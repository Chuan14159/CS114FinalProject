<!doctype html>
<html>

<head>
<title>CS114 Final Project: Water Rendering</title>
<meta charset="utf-8">
<link href="css/proj3.css" rel="stylesheet">

<!-- Useful 3rd party libraries -->
<script type="text/javascript" src="js/jquery-1.12.2.min.js"></script>
<script type="text/javascript" src="js/glMatrix-0.9.5.js"></script>

<!-- Shader initialization utils -->
<script type="text/javascript" src="js/shader-utils.js"></script>

<!-- WebGL debugging utils -->
<script type="text/javascript" src="js/webgl-debug.js"></script>
<script type="text/javascript" src="js/debug-utils.js"></script>

<!-- Simulation-related functions -->
<script type="text/javascript" src="proj3_sim.js"></script>

<!-- WebGL functions -->
<script type="text/javascript" src="proj3_webgl.js"></script>

<!-- Other javascript functions -->
<script type="text/javascript" src="proj3.js"></script>
<script type="text/javascript" src="skybox.js"></script>
<script type="text/javascript" src="pool.js"></script>
<script type="text/javascript" src="waterTexture.js"></script>


<!-- Vertex shader -->
<script id="shader-vs" type="x-shader/x-vertex">
    uniform mat4 uMVMatrix;             // Model-view matrix
    uniform mat4 uPMatrix;              // Projection matrix
    uniform mat4 uNMatrix;              // Normal matrix

    attribute vec3 aVertexPosition;     // Vertex position in object space
    attribute vec3 aVertexNormal;       // Vertex normal in object space

    varying vec3 vPosition;             // Vertex position (camera space)
    varying vec3 vNormal;               // Vertex normal (camera space)

    void main(void) {
    
        vec3 fakePos = aVertexPosition;
        vec3 fakeNormal = aVertexNormal;
    
        vec4 camSpacePosition = uMVMatrix * vec4(aVertexPosition, 1.0);
        vPosition = vec3(camSpacePosition);

        gl_Position = uPMatrix * camSpacePosition;        
        
        
        
        vec4 fakeCamSpacePosition = uMVMatrix * vec4(fakePos, 1.0);
        vPosition = vec3(fakeCamSpacePosition);
        
        
        vec4 camSpaceNormal = uNMatrix * vec4(fakeNormal, 0.0);
        vNormal = vec3(camSpaceNormal);
    }
</script>

<!-- Fragment shader (Blinn-Phong) -->
<script id="shader-fs" type="x-shader/x-fragment">
    precision mediump float;

    uniform vec3 uLightPos;             // Light position in camera space
    varying vec3 vPosition;             // Fragment position (camera space)
    varying vec3 vNormal;               // Fragment normal (camera space)

    uniform samplerCube uSampler;

    void main(void) {
        vec3 vLight = uLightPos - vPosition;
        float dist = length(vLight);
        vLight = vLight/dist;

        vec3 vView = normalize(-vPosition);
        vec3 vHalf = normalize(vView + vLight);
        vec3 vNormal_ = normalize(vNormal);
        if ( dot(vNormal_, vView) < 0.0 ) vNormal_ = -vNormal_;

        vec3 diffClr = vec3(0.2, 0.8, 1);
        float ambient = 0.5;

        float diff = max(dot(vNormal_, vLight), 0.0);
        float spec = pow(max(dot(vNormal_, vHalf), 0.0), 150.0);
        vec3 I = 20.0*(diffClr*diff + spec)/(5.0 + 0.2*dist*dist) + diffClr*ambient;
        
        vec3 refraction = refract(vPosition, vNormal_,1.0/1.33);
        vec3 reflection = reflect(vPosition, vNormal_);
        gl_FragColor = textureCube(uSampler,refraction)*0.4+textureCube(uSampler,reflection)*0.4+vec4(I,1.0)*0.2;
    }
</script>
<!--
arch-skybox
<script id="tex-shader-vs" type="x-shader/x-vertex">
    uniform mat4 uMVMatrix;             // Model-view matrix
    uniform mat4 uPMatrix;              // Projection matrix
    uniform mat4 uNMatrix;              // Normal matrix

    attribute vec3 aVertexPosition;     // Vertex position in object space
    attribute vec3 aVertexNormal;       // Vertex normal in object space

    varying vec3 vPosition;             // Vertex position (camera space)
    varying vec3 vNormal;               // Vertex normal (camera space)

    //arch-skybox
    attribute float a_is_skybox;

    void main(void) {
        vec4 camSpacePosition = uMVMatrix * vec4(aVertexPosition, 1.0);
        vPosition = vec3(camSpacePosition);

        gl_Position = uPMatrix * camSpacePosition;        

        vec4 camSpaceNormal = uNMatrix * vec4(aVertexNormal, 0.0);
        vNormal = vec3(camSpaceNormal);
    }
</script>
-->

<script id="skybox-shader-fs" type="x-shader/x-fragment">
        precision mediump float;

        varying vec3 vVertexPosition;
        
        uniform samplerCube uSampler;
        
        void main(void) {
            gl_FragColor = textureCube(uSampler,vVertexPosition);
        }
</script>

<script id="skybox-shader-vs" type="x-shader/x-vertex">
        attribute vec3 aVertexPosition;
        uniform mat4 uMVMatrix;
        uniform mat4 uPMatrix;
        varying vec3 vVertexPosition;

        void main(void) {
            gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
            vVertexPosition = aVertexPosition;
        }
</script>
    
    
<script id="pool-shader-fs" type="x-shader/x-fragment">
        precision mediump float;

        varying vec3 vVertexPosition;
        uniform vec3 uLightPos;
        uniform samplerCube uSampler;
        uniform vec3 uNormals[900];

        void main(void) {
            if (vVertexPosition[1] <= 1.8){
                gl_FragColor = 0.8*textureCube(uSampler,vVertexPosition) + 0.2*vec4(0.2,0.8,1.0,1.0);
            }
            else{
                gl_FragColor = textureCube(uSampler,vVertexPosition);
            }

            vec3 lightDir = uLightPos - vVertexPosition;
            
            //test if normals of the mesh is passed to shader
            //if sucessful, it will substract green color at the bottom part
            
            vec3 vColor = uNormals[899];
            if (vVertexPosition[1] <= -3.5) 
                gl_FragColor += vec4(vColor,1.0);
            
            // TODO:
            // each vertex normal default is 0,-1,0;
            // Water surface y position is 1.8
            // pool range is x,y,z = [-4.0 to 4.0]
            // Starting from vVertexPosition, trace along lightDir to calculate the point at the height of 1.8, if the point x and z in range -4.0 ~ 4.0, translate the point x and z to the index at uNormals vector[900], find dot(lightDir,normal){^+-*/}STRONGLIGHT and add to gl_FragColor
            
            //(*^â–½^*)
            
            
            
        }
</script>

<script id="pool-shader-vs" type="x-shader/x-vertex">
        attribute vec3 aVertexPosition;
        uniform mat4 uMVMatrix;
        uniform mat4 uPMatrix;
        varying vec3 vVertexPosition;
        void main(void) {
            gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
            vVertexPosition = aVertexPosition;
        }
</script>

    
    
    
<script id="water-shader-fs" type="x-shader/x-fragment">
        precision mediump float;

        varying vec3 vVertexPosition;
        
        uniform samplerCube uSampler;

        void main(void) {
            gl_FragColor = textureCube(uSampler,vVertexPosition);
        }
</script>

<script id="water-shader-vs" type="x-shader/x-vertex">
        attribute vec3 aVertexPosition;
        uniform mat4 uMVMatrix;
        uniform mat4 uPMatrix;
        varying vec3 vVertexPosition;

        void main(void) {
            gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
            vVertexPosition = aVertexPosition;
        }
</script>
    
</head>


<!-- HTML contents -->
<body>
    <h1>CS114 Final Project: Water Rendering</h1>

    <div style="margin-top:10px; float:left">
        <canvas id="canvas0" style="border:none;" width="960" height="720"></canvas>
    </div>
    <div style="margin-left:10px; float:left">
        <div class="panel">
            <p>Rendering Control</p>
            <table>
                <tr>
                    <td width="200px">Resolution</td>
                    <td width="230px">
                        <select onchange="changeResolution(this);">
                            <option value="0">640x480</option>
                            <option value="1">800x600</option>
                            <option value="2" selected="selected">960x720</option>
                        </select>
                    </td>
                </tr>       
                <tr>
                    <td><input type="checkbox" onchange="changeAnimatedLightState(this.checked);" checked>Rotating light</td>
                    <td>
                        <input id="sliderBarLight" type="range" min="1" max="36" value="6" onchange="updateSliderLight(this.value);">
                        (<span id="sliderAmountLight">60</span>&deg;/s)
                    </td>
                </tr>
            </table>
        </div>
        <div style="clear:left"></div>
        
        <p><b><ins>Realtime Water Surface Rendering and Caustics</ins></b></p>
        <p><b>Author:</b></p>
        <p>Changchuan Shen</p>
        <p>Archana Senthilkumar</p>
        <p>Hannah T. Tran</p>
    </div>
    <div style="clear:left"></div>
</body>

</html>
